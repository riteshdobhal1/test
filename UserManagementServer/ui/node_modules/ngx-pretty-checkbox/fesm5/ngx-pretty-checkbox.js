import { Component, ChangeDetectionStrategy, ElementRef, Renderer2, Attribute, Directive, Input, HostBinding, ViewEncapsulation, ChangeDetectorRef, ViewChild, Output, ContentChild, ContentChildren, EventEmitter, ɵɵdefineInjectable, Injectable, Optional, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_PRETTY_CLASS_NAME = 'pretty';
/** @type {?} */
var DEFAULT_PREFIX = 'p-';
/** @type {?} */
var DEFAULT_OUTLINE_PREFIX = '-o';
/** @type {?} */
var GROUP_NAME = 'p-radio';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var PrettyCheckBoxToggleType = {
    On: 'on',
    Off: 'off',
};
/** @enum {string} */
var PrettyCheckboxStroke = {
    // Accept Null
    Fill: 'fill',
    Thick: 'thick',
    Slim: 'slim' // Switch
    ,
};
/** @enum {string} */
var PrettyCheckboxShape = {
    // Accept Null
    Curve: 'curve',
    Round: 'round',
};
/** @enum {string} */
var PrettyCheckboxColor = {
    Primary: 'primary',
    Success: 'success',
    Info: 'info',
    Warning: 'warning',
    Danger: 'danger',
};
/** @enum {string} */
var PrettyCheckboxAnimation = {
    Smooth: 'smooth',
    Jelly: 'jelly',
    Tada: 'tada',
    Rotate: 'rotate',
    Pulse: 'pulse',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyHoverComponent = /** @class */ (function () {
    function NgxPrettyHoverComponent(el, renderer, _outline, _color) {
        if (_outline === void 0) { _outline = false; }
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    NgxPrettyHoverComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
        }
    };
    NgxPrettyHoverComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: "state " + DEFAULT_PREFIX + "is-hover"
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyHoverComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
        { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
    ]; };
    return NgxPrettyHoverComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyIconDirective = /** @class */ (function () {
    function NgxPrettyIconDirective(elemRef) {
        this.elemRef = elemRef;
        this.elemRef.nativeElement.classList.add('icon');
    }
    NgxPrettyIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[pIcon], [p-icon]'
                },] }
    ];
    /** @nocollapse */
    NgxPrettyIconDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return NgxPrettyIconDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyImageDirective = /** @class */ (function () {
    function NgxPrettyImageDirective(elemRef) {
        this.elemRef = elemRef;
        console.log('TCL: NgxPrettyImageDirective -> constructor -> elemRef', elemRef);
        this.elemRef.nativeElement.classList.add('image');
    }
    NgxPrettyImageDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[pImage], [p-image]'
                },] }
    ];
    /** @nocollapse */
    NgxPrettyImageDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return NgxPrettyImageDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyIndeterminateComponent = /** @class */ (function () {
    function NgxPrettyIndeterminateComponent(el, renderer, _outline, _color) {
        if (_outline === void 0) { _outline = false; }
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    NgxPrettyIndeterminateComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
        }
    };
    NgxPrettyIndeterminateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: "state " + DEFAULT_PREFIX + "is-indeterminate"
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyIndeterminateComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
        { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
    ]; };
    return NgxPrettyIndeterminateComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettySvgDirective = /** @class */ (function () {
    function NgxPrettySvgDirective(elemRef) {
        this.elemRef = elemRef;
    }
    /**
     * @return {?}
     */
    NgxPrettySvgDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.elemRef.nativeElement.classList.add('svg');
    };
    NgxPrettySvgDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[pSvg], [p-svg]'
                },] }
    ];
    /** @nocollapse */
    NgxPrettySvgDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return NgxPrettySvgDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyToggleComponent = /** @class */ (function () {
    function NgxPrettyToggleComponent(el, renderer, _outline, _color, _type) {
        if (_outline === void 0) { _outline = false; }
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
        this._type = _type;
    }
    /**
     * @return {?}
     */
    NgxPrettyToggleComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
        }
        this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._type);
    };
    NgxPrettyToggleComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: 'state'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyToggleComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
        { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
        { type: PrettyCheckBoxToggleType, decorators: [{ type: Attribute, args: ['type',] }] }
    ]; };
    return NgxPrettyToggleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} color
 * @param {?=} outline
 * @return {?}
 */
function getColorClassName(color, outline) {
    if (!color) {
        return null;
    }
    return DEFAULT_PREFIX + color + (outline ? DEFAULT_OUTLINE_PREFIX : '');
}
/**
 * @param {?=} str
 * @return {?}
 */
function strToBoolean(str) {
    if (typeof str === 'boolean') {
        return str;
    }
    /** @type {?} */
    var regex = /^\s*(true|1|on|enable)\s*$/i;
    return regex.test(str);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyHoverWillChangeComponent = /** @class */ (function () {
    function NgxPrettyHoverWillChangeComponent(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxPrettyHoverWillChangeComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    };
    NgxPrettyHoverWillChangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: "state " + DEFAULT_PREFIX + "is-hover"
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyHoverWillChangeComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    NgxPrettyHoverWillChangeComponent.propDecorators = {
        color: [{ type: Input }],
        outline: [{ type: Input }]
    };
    return NgxPrettyHoverWillChangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyIndeterminateWillChangeComponent = /** @class */ (function () {
    function NgxPrettyIndeterminateWillChangeComponent(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxPrettyIndeterminateWillChangeComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    };
    NgxPrettyIndeterminateWillChangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: "state " + DEFAULT_PREFIX + "is-indeterminate"
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyIndeterminateWillChangeComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
        color: [{ type: Input }],
        outline: [{ type: Input }]
    };
    return NgxPrettyIndeterminateWillChangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyToggleWillChangeComponent = /** @class */ (function () {
    function NgxPrettyToggleWillChangeComponent(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOn", {
        get: /**
         * @return {?}
         */
        function () { return this.type === PrettyCheckBoxToggleType.On; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOff", {
        get: /**
         * @return {?}
         */
        function () { return this.type === PrettyCheckBoxToggleType.Off; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxPrettyToggleWillChangeComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    };
    NgxPrettyToggleWillChangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                    template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                    host: {
                        class: 'state'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    NgxPrettyToggleWillChangeComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    NgxPrettyToggleWillChangeComponent.propDecorators = {
        type: [{ type: Input }],
        isToggleOn: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "on",] }],
        isToggleOff: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "off",] }],
        color: [{ type: Input }],
        outline: [{ type: Input }]
    };
    return NgxPrettyToggleWillChangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
var NgxPrettyCheckboxComponent = /** @class */ (function () {
    function NgxPrettyCheckboxComponent(renderer, el, cd, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color) {
        if (_isSwitch === void 0) { _isSwitch = false; }
        if (_bigger === void 0) { _bigger = false; }
        if (_enableFocus === void 0) { _enableFocus = false; }
        if (_plain === void 0) { _plain = false; }
        if (_outline === void 0) { _outline = false; }
        this.renderer = renderer;
        this.el = el;
        this.cd = cd;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    NgxPrettyCheckboxComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "switch");
        }
        if (this._bigger) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "bigger");
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "has-focus");
        }
        if (this._plain) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "plain");
        }
        if (this._stroke) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._stroke);
        }
        if (this._shape) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._shape);
        }
        if (this._animation) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._animation);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "icon");
        }
        if (this._svgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "svg");
        }
        if (this._imgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "image");
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "has-hover");
        }
        if (this._indeterminateDir || this._indeterminateWillChangeDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "has-indeterminate");
        }
        if (this._isToggle) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "toggle");
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "default");
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
        }
    };
    // ---------- PRIVATE METHODS ---------
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    NgxPrettyCheckboxComponent.prototype._onChange = 
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    function (event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value: value, checked: checked, event: event });
    };
    Object.defineProperty(NgxPrettyCheckboxComponent.prototype, "_isToggle", {
        get: /**
         * @return {?}
         */
        function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
        enumerable: true,
        configurable: true
    });
    // ---------- PUBLIC METHODS ---------
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    NgxPrettyCheckboxComponent.prototype.setIndeterminate = 
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = true; }
        this._inputElem.nativeElement.indeterminate = value;
    };
    /**
     * @param {?} check
     * @return {?}
     */
    NgxPrettyCheckboxComponent.prototype.forceCheck = /**
     * @param {?} check
     * @return {?}
     */
    function (check) {
        this.checked = check;
        this.cd.markForCheck();
    };
    NgxPrettyCheckboxComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                    template: "\n    <input\n      #inputElem\n      type=\"checkbox\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\n\n      <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n      <label><ng-content></ng-content></label>\n\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                    // changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': DEFAULT_PRETTY_CLASS_NAME
                    },
                    exportAs: 'ngxPrettyCheckbox'
                }] }
    ];
    /** @nocollapse */
    NgxPrettyCheckboxComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
        { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
        { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
        { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
    ]; };
    NgxPrettyCheckboxComponent.propDecorators = {
        checked: [{ type: Input }],
        disabled: [{ type: Input }],
        value: [{ type: Input }],
        lock: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: Input }],
        _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
        _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
        change: [{ type: Output }],
        _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _indeterminateDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
        _indeterminateWillChangeDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
        _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
    };
    return NgxPrettyCheckboxComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
var NgxPrettyCheckboxWillChangeComponent = /** @class */ (function () {
    function NgxPrettyCheckboxWillChangeComponent(cd) {
        this.cd = cd;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked ) 
    }
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isFill", {
        // ---------- STROKE ----------
        // Fill
        get: 
        // To remove the border ( when checkbox is checked ) 
        // ---------- STROKE ----------
        // Fill
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Fill; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSlim", {
        // Slim
        get: 
        // Slim
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Slim; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isThick", {
        // Thick
        get: 
        // Thick
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Thick; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isCurve", {
        // ---------- SHAPE ----------
        // Curve
        get: 
        // ---------- SHAPE ----------
        // Curve
        /**
         * @return {?}
         */
        function () { return this.shape === PrettyCheckboxShape.Curve; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRound", {
        // Round
        get: 
        // Round
        /**
         * @return {?}
         */
        function () { return this.shape === PrettyCheckboxShape.Round; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSmooth", {
        // ---------- ANIMATION ----------
        // Smooth
        get: 
        // ---------- ANIMATION ----------
        // Smooth
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Smooth; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isJelly", {
        // Jelly
        get: 
        // Jelly
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Jelly; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isTada", {
        // Tada
        get: 
        // Tada
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Tada; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRotate", {
        // Rotate
        get: 
        // Rotate
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Rotate; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isPulse", {
        // Pulse
        get: 
        // Pulse
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Pulse; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isToggle", {
        get: /**
         * @return {?}
         */
        function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isDefault", {
        // DEFAULT
        get: 
        // DEFAULT
        /**
         * @return {?}
         */
        function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isHover", {
        get: /**
         * @return {?}
         */
        function () { return this._hoverComp || this._hoverWillChangeDir; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isIndeterminate", {
        get: /**
         * @return {?}
         */
        function () { return this._indeterminateComp || this._indeterminateWillChangeComp; },
        enumerable: true,
        configurable: true
    });
    // ---------- PRIVATE METHODS ---------
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    NgxPrettyCheckboxWillChangeComponent.prototype._onChange = 
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    function (event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value: value, checked: checked, event: event });
    };
    // ---------- PUBLIC METHODS ---------
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    NgxPrettyCheckboxWillChangeComponent.prototype.setIndeterminate = 
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = true; }
        this._inputElem.nativeElement.indeterminate = value;
    };
    /**
     * @param {?} check
     * @return {?}
     */
    NgxPrettyCheckboxWillChangeComponent.prototype.forceCheck = /**
     * @param {?} check
     * @return {?}
     */
    function (check) {
        this.checked = check;
        this.cd.markForCheck();
    };
    NgxPrettyCheckboxWillChangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                    template: "\n    <input\n      #inputElem\n      type=\"checkbox\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div *ngIf=\"!_isToggle\" class=\"state\"\n        [ngClass]=\"[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]\">\n\n        <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n        <label><ng-content></ng-content></label>\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': DEFAULT_PRETTY_CLASS_NAME
                    },
                    exportAs: 'ngxPrettyCheckboxWillChange'
                }] }
    ];
    /** @nocollapse */
    NgxPrettyCheckboxWillChangeComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    NgxPrettyCheckboxWillChangeComponent.propDecorators = {
        _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
        change: [{ type: Output }],
        stroke: [{ type: Input }],
        shape: [{ type: Input }],
        animation: [{ type: Input }],
        color: [{ type: Input }],
        outline: [{ type: Input }],
        checked: [{ type: Input }],
        disabled: [{ type: Input }],
        value: [{ type: Input }],
        isSwitch: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "switch",] }, { type: Input }],
        lock: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: Input }],
        bigger: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "bigger",] }, { type: Input }],
        enableFocus: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "has-focus",] }, { type: Input }],
        plain: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "plain",] }, { type: Input }],
        _isFill: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Fill,] }],
        _isSlim: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Slim,] }],
        _isThick: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Thick,] }],
        _isCurve: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Curve,] }],
        _isRound: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Round,] }],
        _isSmooth: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Smooth,] }],
        _isJelly: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Jelly,] }],
        _isTada: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Tada,] }],
        _isRotate: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Rotate,] }],
        _isPulse: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Pulse,] }],
        _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
        _isToggle: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "toggle",] }],
        _isDefault: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "default",] }],
        _iconElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "icon",] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "svg",] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imageElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "image",] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _isHover: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "has-hover",] }],
        _indeterminateComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
        _indeterminateWillChangeComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
        _isIndeterminate: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "has-indeterminate",] }]
    };
    return NgxPrettyCheckboxWillChangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPrettyRadioService = /** @class */ (function () {
    function NgxPrettyRadioService() {
    }
    NgxPrettyRadioService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    NgxPrettyRadioService.ctorParameters = function () { return []; };
    /** @nocollapse */ NgxPrettyRadioService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxPrettyRadioService_Factory() { return new NgxPrettyRadioService(); }, token: NgxPrettyRadioService, providedIn: "root" });
    return NgxPrettyRadioService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nextId = 1;
var NgxPrettyRadioGroupDirective = /** @class */ (function () {
    function NgxPrettyRadioGroupDirective() {
        this.name = GROUP_NAME + nextId++;
        this.change = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    NgxPrettyRadioGroupDirective.prototype._emitChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.change.emit(event);
    };
    NgxPrettyRadioGroupDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ngx-pretty-radio-group, p-radio-group',
                    providers: [NgxPrettyRadioService],
                    exportAs: 'ngxRadioGroup'
                },] }
    ];
    /** @nocollapse */
    NgxPrettyRadioGroupDirective.ctorParameters = function () { return []; };
    NgxPrettyRadioGroupDirective.propDecorators = {
        change: [{ type: Output }]
    };
    return NgxPrettyRadioGroupDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
var NgxPrettyRadioComponent = /** @class */ (function () {
    function NgxPrettyRadioComponent(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color, _name) {
        if (_isSwitch === void 0) { _isSwitch = false; }
        if (_bigger === void 0) { _bigger = false; }
        if (_enableFocus === void 0) { _enableFocus = false; }
        if (_plain === void 0) { _plain = false; }
        if (_outline === void 0) { _outline = false; }
        this.renderer = renderer;
        this.el = el;
        this.radioGroup = radioGroup;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._name = _name;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        if (!this._name && this.radioGroup) {
            this._name = this.radioGroup.name;
        }
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    NgxPrettyRadioComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "switch");
        }
        if (this._bigger) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "bigger");
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "has-focus");
        }
        if (this._plain) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "plain");
        }
        if (this._stroke) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._stroke);
        }
        if (this._shape) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._shape);
        }
        if (this._animation) {
            this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._animation);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "icon");
        }
        if (this._svgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "svg");
        }
        if (this._imgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "image");
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "has-hover");
        }
        if (this._isToggle) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "toggle");
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, DEFAULT_PREFIX + "default");
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
        }
    };
    // ---------- METHODS ---------
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    NgxPrettyRadioComponent.prototype._onChange = 
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    function (event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value: value, checked: checked, event: event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value: value, checked: checked, event: event });
        }
    };
    Object.defineProperty(NgxPrettyRadioComponent.prototype, "_isToggle", {
        get: /**
         * @return {?}
         */
        function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
        enumerable: true,
        configurable: true
    });
    NgxPrettyRadioComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                    template: "\n    <input\n      #inputElem\n      type=\"radio\"\n      [name]=\"_name\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\n\n      <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n      <label><ng-content></ng-content></label>\n\n    </div>\n\n    <ng-content select=\"ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                    // changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': DEFAULT_PRETTY_CLASS_NAME
                    },
                    exportAs: 'ngxPrettyRadio'
                }] }
    ];
    /** @nocollapse */
    NgxPrettyRadioComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] },
        { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
        { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
        { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
        { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
        { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
        { type: String, decorators: [{ type: Attribute, args: ['name',] }] }
    ]; };
    NgxPrettyRadioComponent.propDecorators = {
        checked: [{ type: Input }],
        disabled: [{ type: Input }],
        value: [{ type: Input }],
        lock: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: Input }],
        _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
        _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
        change: [{ type: Output }],
        _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
    };
    return NgxPrettyRadioComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
var NgxPrettyRadioWillChangeComponent = /** @class */ (function () {
    function NgxPrettyRadioWillChangeComponent(radioGroup) {
        this.radioGroup = radioGroup;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked )
        if (radioGroup) {
            this.radioGroupName = radioGroup.name;
        }
    }
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isFill", {
        // ---------- STROKE ----------
        // Fill
        get: 
        // To remove the border ( when checkbox is checked )
        // ---------- STROKE ----------
        // Fill
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Fill; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSlim", {
        // Slim
        get: 
        // Slim
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Slim; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isThick", {
        // Thick
        get: 
        // Thick
        /**
         * @return {?}
         */
        function () { return this.stroke === PrettyCheckboxStroke.Thick; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isCurve", {
        // ---------- SHAPE ----------
        // Curve
        get: 
        // ---------- SHAPE ----------
        // Curve
        /**
         * @return {?}
         */
        function () { return this.shape === PrettyCheckboxShape.Curve; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRound", {
        // Round
        get: 
        // Round
        /**
         * @return {?}
         */
        function () { return this.shape === PrettyCheckboxShape.Round; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSmooth", {
        // ---------- ANIMATION ----------
        // Smooth
        get: 
        // ---------- ANIMATION ----------
        // Smooth
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Smooth; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isJelly", {
        // Jelly
        get: 
        // Jelly
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Jelly; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isTada", {
        // Tada
        get: 
        // Tada
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Tada; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRotate", {
        // Rotate
        get: 
        // Rotate
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Rotate; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isPulse", {
        // Pulse
        get: 
        // Pulse
        /**
         * @return {?}
         */
        function () { return this.animation === PrettyCheckboxAnimation.Pulse; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isToggle", {
        get: /**
         * @return {?}
         */
        function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isDefault", {
        // DEFAULT
        get: 
        // DEFAULT
        /**
         * @return {?}
         */
        function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isHover", {
        get: /**
         * @return {?}
         */
        function () { return this._hoverComp || this._hoverWillChangeDir; },
        enumerable: true,
        configurable: true
    });
    // ---------- METHODS ---------
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    NgxPrettyRadioWillChangeComponent.prototype._onChange = 
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    function (event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value: value, checked: checked, event: event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value: value, checked: checked, event: event });
        }
    };
    NgxPrettyRadioWillChangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                    template: "\n    <input\n      #inputElem\n      type=\"radio\"\n      [name]=\"name || radioGroupName\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div *ngIf=\"!_isToggle\" class=\"state\"\n        [ngClass]=\"[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]\">\n\n        <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n        <label><ng-content></ng-content></label>\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    host: {
                        'class': DEFAULT_PRETTY_CLASS_NAME
                    },
                    exportAs: 'ngxPrettyRadio'
                }] }
    ];
    /** @nocollapse */
    NgxPrettyRadioWillChangeComponent.ctorParameters = function () { return [
        { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    NgxPrettyRadioWillChangeComponent.propDecorators = {
        _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
        change: [{ type: Output }],
        stroke: [{ type: Input }],
        shape: [{ type: Input }],
        animation: [{ type: Input }],
        color: [{ type: Input }],
        outline: [{ type: Input }],
        checked: [{ type: Input }],
        disabled: [{ type: Input }],
        value: [{ type: Input }],
        name: [{ type: Input }],
        isSwitch: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "switch",] }, { type: Input }],
        lock: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: Input }],
        bigger: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "bigger",] }, { type: Input }],
        enableFocus: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "has-focus",] }, { type: Input }],
        plain: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "plain",] }, { type: Input }],
        _isFill: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Fill,] }],
        _isSlim: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Slim,] }],
        _isThick: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Thick,] }],
        _isCurve: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Curve,] }],
        _isRound: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Round,] }],
        _isSmooth: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Smooth,] }],
        _isJelly: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Jelly,] }],
        _isTada: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Tada,] }],
        _isRotate: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Rotate,] }],
        _isPulse: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Pulse,] }],
        _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
        _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
        _isToggle: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "toggle",] }],
        _isDefault: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "default",] }],
        _iconElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "icon",] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
        _svgElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "svg",] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
        _imageElem: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "image",] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
        _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
        _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
        _isHover: [{ type: HostBinding, args: ["class." + DEFAULT_PREFIX + "has-hover",] }]
    };
    return NgxPrettyRadioWillChangeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DECLARATIONS = [
    NgxPrettyCheckboxComponent,
    NgxPrettyCheckboxWillChangeComponent,
    NgxPrettyIconDirective,
    NgxPrettySvgDirective,
    NgxPrettyImageDirective,
    NgxPrettyToggleComponent,
    NgxPrettyToggleWillChangeComponent,
    NgxPrettyHoverComponent,
    NgxPrettyHoverWillChangeComponent,
    NgxPrettyIndeterminateComponent,
    NgxPrettyIndeterminateWillChangeComponent,
    NgxPrettyRadioGroupDirective,
    NgxPrettyRadioComponent,
    NgxPrettyRadioWillChangeComponent
];
var NgxPrettyCheckboxModule = /** @class */ (function () {
    function NgxPrettyCheckboxModule() {
    }
    NgxPrettyCheckboxModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule
                    ],
                    declarations: [DECLARATIONS],
                    exports: [DECLARATIONS]
                },] }
    ];
    return NgxPrettyCheckboxModule;
}());

export { NgxPrettyCheckboxComponent, NgxPrettyCheckboxModule, NgxPrettyCheckboxWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIconDirective, NgxPrettyImageDirective, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioWillChangeComponent, NgxPrettySvgDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, PrettyCheckBoxToggleType, PrettyCheckboxAnimation, PrettyCheckboxColor, PrettyCheckboxShape, PrettyCheckboxStroke, DEFAULT_PRETTY_CLASS_NAME as ɵa, DEFAULT_PREFIX as ɵb, NgxPrettyRadioService as ɵc };
//# sourceMappingURL=ngx-pretty-checkbox.js.map
