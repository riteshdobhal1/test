import { Component, ChangeDetectionStrategy, ElementRef, Renderer2, Attribute, Directive, Input, HostBinding, EventEmitter, ViewEncapsulation, ChangeDetectorRef, ViewChild, Output, ContentChild, ContentChildren, Injectable, ɵɵdefineInjectable, Optional, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_PRETTY_CLASS_NAME = 'pretty';
/** @type {?} */
const DEFAULT_PREFIX = 'p-';
/** @type {?} */
const DEFAULT_OUTLINE_PREFIX = '-o';
/** @type {?} */
const GROUP_NAME = 'p-radio';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const PrettyCheckBoxToggleType = {
    On: 'on',
    Off: 'off',
};
/** @enum {string} */
const PrettyCheckboxStroke = {
    // Accept Null
    Fill: 'fill',
    Thick: 'thick',
    Slim: 'slim' // Switch
    ,
};
/** @enum {string} */
const PrettyCheckboxShape = {
    // Accept Null
    Curve: 'curve',
    Round: 'round',
};
/** @enum {string} */
const PrettyCheckboxColor = {
    Primary: 'primary',
    Success: 'success',
    Info: 'info',
    Warning: 'warning',
    Danger: 'danger',
};
/** @enum {string} */
const PrettyCheckboxAnimation = {
    Smooth: 'smooth',
    Jelly: 'jelly',
    Tada: 'tada',
    Rotate: 'rotate',
    Pulse: 'pulse',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyHoverComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
}
NgxPrettyHoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyHoverComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIconDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
        this.elemRef.nativeElement.classList.add('icon');
    }
}
NgxPrettyIconDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pIcon], [p-icon]'
            },] }
];
/** @nocollapse */
NgxPrettyIconDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyImageDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
        console.log('TCL: NgxPrettyImageDirective -> constructor -> elemRef', elemRef);
        this.elemRef.nativeElement.classList.add('image');
    }
}
NgxPrettyImageDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pImage], [p-image]'
            },] }
];
/** @nocollapse */
NgxPrettyImageDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIndeterminateComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(el, renderer, _outline = false, _color) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
}
NgxPrettyIndeterminateComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyIndeterminateComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettySvgDirective {
    /**
     * @param {?} elemRef
     */
    constructor(elemRef) {
        this.elemRef = elemRef;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.elemRef.nativeElement.classList.add('svg');
    }
}
NgxPrettySvgDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pSvg], [p-svg]'
            },] }
];
/** @nocollapse */
NgxPrettySvgDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyToggleComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?=} _outline
     * @param {?=} _color
     * @param {?=} _type
     */
    constructor(el, renderer, _outline = false, _color, _type) {
        this.el = el;
        this.renderer = renderer;
        this._outline = _outline;
        this._color = _color;
        this._type = _type;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._color) {
            this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
        this.renderer.addClass(this.el.nativeElement, `${DEFAULT_PREFIX}${this._type}`);
    }
}
NgxPrettyToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: 'state'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyToggleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: PrettyCheckBoxToggleType, decorators: [{ type: Attribute, args: ['type',] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} color
 * @param {?=} outline
 * @return {?}
 */
function getColorClassName(color, outline) {
    if (!color) {
        return null;
    }
    return DEFAULT_PREFIX + color + (outline ? DEFAULT_OUTLINE_PREFIX : '');
}
/**
 * @param {?=} str
 * @return {?}
 */
function strToBoolean(str) {
    if (typeof str === 'boolean') {
        return str;
    }
    /** @type {?} */
    const regex = /^\s*(true|1|on|enable)\s*$/i;
    return regex.test(str);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyHoverWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyHoverWillChangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-hover`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyHoverWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyHoverWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyIndeterminateWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyIndeterminateWillChangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: `state ${DEFAULT_PREFIX}is-indeterminate`
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyIndeterminateWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
    color: [{ type: Input }],
    outline: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyToggleWillChangeComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.outline = false;
    }
    /**
     * @return {?}
     */
    get isToggleOn() { return this.type === PrettyCheckBoxToggleType.On; }
    /**
     * @return {?}
     */
    get isToggleOff() { return this.type === PrettyCheckBoxToggleType.Off; }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.color || changes.outline) {
            /** @type {?} */
            const oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
            /** @type {?} */
            const newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
            this.renderer.removeClass(this.el.nativeElement, oldClass);
            this.renderer.addClass(this.el.nativeElement, newClass);
        }
    }
}
NgxPrettyToggleWillChangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                template: `
    <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
    <label><ng-content></ng-content></label>
  `,
                host: {
                    class: 'state'
                },
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
NgxPrettyToggleWillChangeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
NgxPrettyToggleWillChangeComponent.propDecorators = {
    type: [{ type: Input }],
    isToggleOn: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}on`,] }],
    isToggleOff: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}off`,] }],
    color: [{ type: Input }],
    outline: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyCheckboxComponent {
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} cd
     * @param {?} _stroke
     * @param {?} _shape
     * @param {?} _animation
     * @param {?=} _isSwitch
     * @param {?=} _bigger
     * @param {?=} _enableFocus
     * @param {?=} _plain
     * @param {?=} _outline
     * @param {?=} _color
     */
    constructor(renderer, el, cd, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color) {
        this.renderer = renderer;
        this.el = el;
        this.cd = cd;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-hover`);
        }
        if (this._indeterminateDir || this._indeterminateWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-indeterminate`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    /**
     * @param {?} check
     * @return {?}
     */
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                template: `
    <input
      #inputElem
      type="checkbox"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div #stateElem *ngIf="!_isToggle" class="state">

      <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
      <label><ng-content></ng-content></label>

    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                // changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyCheckbox'
            }] }
];
/** @nocollapse */
NgxPrettyCheckboxComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] }
];
NgxPrettyCheckboxComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _indeterminateDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeDir: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyCheckboxWillChangeComponent {
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked ) 
    }
    // To remove the border ( when checkbox is checked ) 
    // ---------- STROKE ----------
    // Fill
    /**
     * @return {?}
     */
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    // Slim
    /**
     * @return {?}
     */
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    // Thick
    /**
     * @return {?}
     */
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    // Curve
    /**
     * @return {?}
     */
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    // Round
    /**
     * @return {?}
     */
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    // Smooth
    /**
     * @return {?}
     */
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    // Jelly
    /**
     * @return {?}
     */
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    // Tada
    /**
     * @return {?}
     */
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    // Rotate
    /**
     * @return {?}
     */
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    // Pulse
    /**
     * @return {?}
     */
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    /**
     * @return {?}
     */
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    /**
     * @return {?}
     */
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    /**
     * @return {?}
     */
    get _isIndeterminate() { return this._indeterminateComp || this._indeterminateWillChangeComp; }
    // ---------- PRIVATE METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.checked = checked;
        this.change.emit({ value, checked, event });
    }
    // ---------- PUBLIC METHODS ---------
    /**
     * @param {?=} value
     * @return {?}
     */
    setIndeterminate(value = true) {
        this._inputElem.nativeElement.indeterminate = value;
    }
    /**
     * @param {?} check
     * @return {?}
     */
    forceCheck(check) {
        this.checked = check;
        this.cd.markForCheck();
    }
}
NgxPrettyCheckboxWillChangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                template: `
    <input
      #inputElem
      type="checkbox"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div *ngIf="!_isToggle" class="state"
        [ngClass]="[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]">

        <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
        <label><ng-content></ng-content></label>
    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyCheckboxWillChange'
            }] }
];
/** @nocollapse */
NgxPrettyCheckboxWillChangeComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
NgxPrettyCheckboxWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    isSwitch: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}switch`,] }, { type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    bigger: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}bigger`,] }, { type: Input }],
    enableFocus: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-focus`,] }, { type: Input }],
    plain: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}plain`,] }, { type: Input }],
    _isFill: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`,] }],
    _isSlim: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`,] }],
    _isThick: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`,] }],
    _isCurve: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`,] }],
    _isRound: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`,] }],
    _isSmooth: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`,] }],
    _isJelly: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`,] }],
    _isTada: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`,] }],
    _isRotate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`,] }],
    _isPulse: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`,] }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _isToggle: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}toggle`,] }],
    _isDefault: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}default`,] }],
    _iconElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}icon`,] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}svg`,] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}image`,] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _isHover: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-hover`,] }],
    _indeterminateComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
    _indeterminateWillChangeComp: [{ type: ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
    _isIndeterminate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-indeterminate`,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrettyRadioService {
    constructor() { }
}
NgxPrettyRadioService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgxPrettyRadioService.ctorParameters = () => [];
/** @nocollapse */ NgxPrettyRadioService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxPrettyRadioService_Factory() { return new NgxPrettyRadioService(); }, token: NgxPrettyRadioService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
let nextId = 1;
class NgxPrettyRadioGroupDirective {
    constructor() {
        this.name = GROUP_NAME + nextId++;
        this.change = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _emitChange(event) {
        this.change.emit(event);
    }
}
NgxPrettyRadioGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: 'ngx-pretty-radio-group, p-radio-group',
                providers: [NgxPrettyRadioService],
                exportAs: 'ngxRadioGroup'
            },] }
];
/** @nocollapse */
NgxPrettyRadioGroupDirective.ctorParameters = () => [];
NgxPrettyRadioGroupDirective.propDecorators = {
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyRadioComponent {
    /**
     * @param {?} renderer
     * @param {?} el
     * @param {?} radioGroup
     * @param {?} _stroke
     * @param {?} _shape
     * @param {?} _animation
     * @param {?=} _isSwitch
     * @param {?=} _bigger
     * @param {?=} _enableFocus
     * @param {?=} _plain
     * @param {?=} _outline
     * @param {?=} _color
     * @param {?=} _name
     */
    constructor(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch = false, _bigger = false, _enableFocus = false, _plain = false, _outline = false, _color, _name) {
        this.renderer = renderer;
        this.el = el;
        this.radioGroup = radioGroup;
        this._stroke = _stroke;
        this._shape = _shape;
        this._animation = _animation;
        this._isSwitch = _isSwitch;
        this._bigger = _bigger;
        this._enableFocus = _enableFocus;
        this._plain = _plain;
        this._outline = _outline;
        this._color = _color;
        this._name = _name;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.checked = false;
        this.disabled = false;
        this.lock = false;
        this.change = new EventEmitter();
        if (!this._name && this.radioGroup) {
            this._name = this.radioGroup.name;
        }
        this._isSwitch = strToBoolean(this._isSwitch);
        this._bigger = strToBoolean(this._bigger);
        this._enableFocus = strToBoolean(this._enableFocus);
        this._plain = strToBoolean(this._plain);
        this._outline = strToBoolean(this._outline);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const el = this.el.nativeElement;
        if (this._isSwitch) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}switch`);
        }
        if (this._bigger) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}bigger`);
        }
        if (this._enableFocus) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-focus`);
        }
        if (this._plain) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}plain`);
        }
        if (this._stroke) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._stroke}`);
        }
        if (this._shape) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._shape}`);
        }
        if (this._animation) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}${this._animation}`);
        }
        if (this._iconDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}icon`);
        }
        if (this._svgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}svg`);
        }
        if (this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}image`);
        }
        if (this._hoverDir || this._hoverWillChangeDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}has-hover`);
        }
        if (this._isToggle) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}toggle`);
        }
        if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
            this.renderer.addClass(el, `${DEFAULT_PREFIX}default`);
        }
        // STATE ELEM
        if (this._color && !this._isToggle) {
            this.renderer.addClass(this._stateElem.nativeElement, `${DEFAULT_PREFIX}${this._color}${this._outline ? DEFAULT_OUTLINE_PREFIX : ''}`);
        }
    }
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; }
}
NgxPrettyRadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                template: `
    <input
      #inputElem
      type="radio"
      [name]="_name"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div #stateElem *ngIf="!_isToggle" class="state">

      <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
      <label><ng-content></ng-content></label>

    </div>

    <ng-content select="ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                // changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyRadio'
            }] }
];
/** @nocollapse */
NgxPrettyRadioComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] },
    { type: PrettyCheckboxStroke, decorators: [{ type: Attribute, args: ['stroke',] }] },
    { type: PrettyCheckboxShape, decorators: [{ type: Attribute, args: ['shape',] }] },
    { type: PrettyCheckboxAnimation, decorators: [{ type: Attribute, args: ['animation',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['isSwitch',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['bigger',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['enableFocus',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['plain',] }] },
    { type: undefined, decorators: [{ type: Attribute, args: ['outline',] }] },
    { type: PrettyCheckboxColor, decorators: [{ type: Attribute, args: ['color',] }] },
    { type: String, decorators: [{ type: Attribute, args: ['name',] }] }
];
NgxPrettyRadioComponent.propDecorators = {
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    _stateElem: [{ type: ViewChild, args: ['stateElem', { static: false },] }],
    change: [{ type: Output }],
    _iconDir: [{ type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgDir: [{ type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imgDir: [{ type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverDir: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _toggleComps: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComps: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:use-host-property-decorator
class NgxPrettyRadioWillChangeComponent {
    /**
     * @param {?} radioGroup
     */
    constructor(radioGroup) {
        this.radioGroup = radioGroup;
        this._prefix = DEFAULT_PREFIX;
        this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
        this.change = new EventEmitter();
        this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
        this.checked = false;
        this.disabled = false;
        // ----- INPUTS AND BINDING ------
        // SWITCH
        this.isSwitch = false;
        //  LOCK
        this.lock = false;
        //  BIGGER
        this.bigger = false;
        //  FOCUS
        this.enableFocus = false;
        //  PLAIN
        this.plain = false; // To remove the border ( when checkbox is checked )
        if (radioGroup) {
            this.radioGroupName = radioGroup.name;
        }
    }
    // To remove the border ( when checkbox is checked )
    // ---------- STROKE ----------
    // Fill
    /**
     * @return {?}
     */
    get _isFill() { return this.stroke === PrettyCheckboxStroke.Fill; }
    // Slim
    /**
     * @return {?}
     */
    get _isSlim() { return this.stroke === PrettyCheckboxStroke.Slim; }
    // Thick
    /**
     * @return {?}
     */
    get _isThick() { return this.stroke === PrettyCheckboxStroke.Thick; }
    // ---------- SHAPE ----------
    // Curve
    /**
     * @return {?}
     */
    get _isCurve() { return this.shape === PrettyCheckboxShape.Curve; }
    // Round
    /**
     * @return {?}
     */
    get _isRound() { return this.shape === PrettyCheckboxShape.Round; }
    // ---------- ANIMATION ----------
    // Smooth
    /**
     * @return {?}
     */
    get _isSmooth() { return this.animation === PrettyCheckboxAnimation.Smooth; }
    // Jelly
    /**
     * @return {?}
     */
    get _isJelly() { return this.animation === PrettyCheckboxAnimation.Jelly; }
    // Tada
    /**
     * @return {?}
     */
    get _isTada() { return this.animation === PrettyCheckboxAnimation.Tada; }
    // Rotate
    /**
     * @return {?}
     */
    get _isRotate() { return this.animation === PrettyCheckboxAnimation.Rotate; }
    // Pulse
    /**
     * @return {?}
     */
    get _isPulse() { return this.animation === PrettyCheckboxAnimation.Pulse; }
    /**
     * @return {?}
     */
    get _isToggle() { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; }
    // DEFAULT
    /**
     * @return {?}
     */
    get _isDefault() { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; }
    /**
     * @return {?}
     */
    get _isHover() { return this._hoverComp || this._hoverWillChangeDir; }
    // ---------- METHODS ---------
    /**
     * @param {?} event
     * @param {?} checked
     * @param {?} value
     * @return {?}
     */
    _onChange(event, checked, value) {
        // I stop propagation on the change event.
        // Otherwise the change event, from the input element, will bubble up and
        event.stopPropagation();
        this.change.emit({ value, checked, event });
        if (this.radioGroup) {
            this.radioGroup._emitChange({ value, checked, event });
        }
    }
}
NgxPrettyRadioWillChangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                template: `
    <input
      #inputElem
      type="radio"
      [name]="name || radioGroupName"
      [value]="value"
      [checked]="checked"
      [disabled]="disabled"
      (change)="_onChange($event, inputElem.checked, inputElem.value)"/>

    <div *ngIf="!_isToggle" class="state"
        [ngClass]="[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]">

        <ng-content select="[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]"></ng-content>
        <label><ng-content></ng-content></label>
    </div>

    <ng-content select="ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': DEFAULT_PRETTY_CLASS_NAME
                },
                exportAs: 'ngxPrettyRadio'
            }] }
];
/** @nocollapse */
NgxPrettyRadioWillChangeComponent.ctorParameters = () => [
    { type: NgxPrettyRadioGroupDirective, decorators: [{ type: Optional }] }
];
NgxPrettyRadioWillChangeComponent.propDecorators = {
    _inputElem: [{ type: ViewChild, args: ['inputElem', { static: true },] }],
    change: [{ type: Output }],
    stroke: [{ type: Input }],
    shape: [{ type: Input }],
    animation: [{ type: Input }],
    color: [{ type: Input }],
    outline: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    isSwitch: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}switch`,] }, { type: Input }],
    lock: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}locked`,] }, { type: Input }],
    bigger: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}bigger`,] }, { type: Input }],
    enableFocus: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-focus`,] }, { type: Input }],
    plain: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}plain`,] }, { type: Input }],
    _isFill: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Fill}`,] }],
    _isSlim: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Slim}`,] }],
    _isThick: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxStroke.Thick}`,] }],
    _isCurve: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Curve}`,] }],
    _isRound: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxShape.Round}`,] }],
    _isSmooth: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Smooth}`,] }],
    _isJelly: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Jelly}`,] }],
    _isTada: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Tada}`,] }],
    _isRotate: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Rotate}`,] }],
    _isPulse: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}${PrettyCheckboxAnimation.Pulse}`,] }],
    _toggleComp: [{ type: ContentChildren, args: [NgxPrettyToggleComponent,] }],
    _toggleWillChangeComp: [{ type: ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
    _isToggle: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}toggle`,] }],
    _isDefault: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}default`,] }],
    _iconElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}icon`,] }, { type: ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
    _svgElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}svg`,] }, { type: ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
    _imageElem: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}image`,] }, { type: ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
    _hoverWillChangeDir: [{ type: ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
    _hoverComp: [{ type: ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
    _isHover: [{ type: HostBinding, args: [`class.${DEFAULT_PREFIX}has-hover`,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DECLARATIONS = [
    NgxPrettyCheckboxComponent,
    NgxPrettyCheckboxWillChangeComponent,
    NgxPrettyIconDirective,
    NgxPrettySvgDirective,
    NgxPrettyImageDirective,
    NgxPrettyToggleComponent,
    NgxPrettyToggleWillChangeComponent,
    NgxPrettyHoverComponent,
    NgxPrettyHoverWillChangeComponent,
    NgxPrettyIndeterminateComponent,
    NgxPrettyIndeterminateWillChangeComponent,
    NgxPrettyRadioGroupDirective,
    NgxPrettyRadioComponent,
    NgxPrettyRadioWillChangeComponent
];
class NgxPrettyCheckboxModule {
}
NgxPrettyCheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule
                ],
                declarations: [DECLARATIONS],
                exports: [DECLARATIONS]
            },] }
];

export { NgxPrettyCheckboxComponent, NgxPrettyCheckboxModule, NgxPrettyCheckboxWillChangeComponent, NgxPrettyHoverComponent, NgxPrettyHoverWillChangeComponent, NgxPrettyIconDirective, NgxPrettyImageDirective, NgxPrettyIndeterminateComponent, NgxPrettyIndeterminateWillChangeComponent, NgxPrettyRadioComponent, NgxPrettyRadioGroupDirective, NgxPrettyRadioWillChangeComponent, NgxPrettySvgDirective, NgxPrettyToggleComponent, NgxPrettyToggleWillChangeComponent, PrettyCheckBoxToggleType, PrettyCheckboxAnimation, PrettyCheckboxColor, PrettyCheckboxShape, PrettyCheckboxStroke, DEFAULT_PRETTY_CLASS_NAME as ɵa, DEFAULT_PREFIX as ɵb, NgxPrettyRadioService as ɵc };
//# sourceMappingURL=ngx-pretty-checkbox.js.map
