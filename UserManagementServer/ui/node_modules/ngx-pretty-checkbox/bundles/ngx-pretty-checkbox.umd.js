(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('ngx-pretty-checkbox', ['exports', '@angular/core', '@angular/common', '@angular/forms'], factory) :
    (global = global || self, factory(global['ngx-pretty-checkbox'] = {}, global.ng.core, global.ng.common, global.ng.forms));
}(this, function (exports, core, common, forms) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_PRETTY_CLASS_NAME = 'pretty';
    /** @type {?} */
    var DEFAULT_PREFIX = 'p-';
    /** @type {?} */
    var DEFAULT_OUTLINE_PREFIX = '-o';
    /** @type {?} */
    var GROUP_NAME = 'p-radio';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var PrettyCheckBoxToggleType = {
        On: 'on',
        Off: 'off',
    };
    /** @enum {string} */
    var PrettyCheckboxStroke = {
        // Accept Null
        Fill: 'fill',
        Thick: 'thick',
        Slim: 'slim' // Switch
        ,
    };
    /** @enum {string} */
    var PrettyCheckboxShape = {
        // Accept Null
        Curve: 'curve',
        Round: 'round',
    };
    /** @enum {string} */
    var PrettyCheckboxColor = {
        Primary: 'primary',
        Success: 'success',
        Info: 'info',
        Warning: 'warning',
        Danger: 'danger',
    };
    /** @enum {string} */
    var PrettyCheckboxAnimation = {
        Smooth: 'smooth',
        Jelly: 'jelly',
        Tada: 'tada',
        Rotate: 'rotate',
        Pulse: 'pulse',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyHoverComponent = /** @class */ (function () {
        function NgxPrettyHoverComponent(el, renderer, _outline, _color) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
        }
        /**
         * @return {?}
         */
        NgxPrettyHoverComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
            }
        };
        NgxPrettyHoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-hover:not([will-change]), p-hover:not([will-change])',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: "state " + DEFAULT_PREFIX + "is-hover"
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyHoverComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
            { type: PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
        ]; };
        return NgxPrettyHoverComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyIconDirective = /** @class */ (function () {
        function NgxPrettyIconDirective(elemRef) {
            this.elemRef = elemRef;
            this.elemRef.nativeElement.classList.add('icon');
        }
        NgxPrettyIconDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[pIcon], [p-icon]'
                    },] }
        ];
        /** @nocollapse */
        NgxPrettyIconDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return NgxPrettyIconDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyImageDirective = /** @class */ (function () {
        function NgxPrettyImageDirective(elemRef) {
            this.elemRef = elemRef;
            console.log('TCL: NgxPrettyImageDirective -> constructor -> elemRef', elemRef);
            this.elemRef.nativeElement.classList.add('image');
        }
        NgxPrettyImageDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[pImage], [p-image]'
                    },] }
        ];
        /** @nocollapse */
        NgxPrettyImageDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return NgxPrettyImageDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyIndeterminateComponent = /** @class */ (function () {
        function NgxPrettyIndeterminateComponent(el, renderer, _outline, _color) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
        }
        /**
         * @return {?}
         */
        NgxPrettyIndeterminateComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
            }
        };
        NgxPrettyIndeterminateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-indeterminate:not([will-change]), p-indeterminate:not([will-change])',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: "state " + DEFAULT_PREFIX + "is-indeterminate"
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyIndeterminateComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
            { type: PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
        ]; };
        return NgxPrettyIndeterminateComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettySvgDirective = /** @class */ (function () {
        function NgxPrettySvgDirective(elemRef) {
            this.elemRef = elemRef;
        }
        /**
         * @return {?}
         */
        NgxPrettySvgDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.elemRef.nativeElement.classList.add('svg');
        };
        NgxPrettySvgDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[pSvg], [p-svg]'
                    },] }
        ];
        /** @nocollapse */
        NgxPrettySvgDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return NgxPrettySvgDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyToggleComponent = /** @class */ (function () {
        function NgxPrettyToggleComponent(el, renderer, _outline, _color, _type) {
            if (_outline === void 0) { _outline = false; }
            this.el = el;
            this.renderer = renderer;
            this._outline = _outline;
            this._color = _color;
            this._type = _type;
        }
        /**
         * @return {?}
         */
        NgxPrettyToggleComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (this._color) {
                this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
            }
            this.renderer.addClass(this.el.nativeElement, "" + DEFAULT_PREFIX + this._type);
        };
        NgxPrettyToggleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-toggle:not([will-change]), p-toggle:not([will-change])',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: 'state'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyToggleComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
            { type: PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] },
            { type: PrettyCheckBoxToggleType, decorators: [{ type: core.Attribute, args: ['type',] }] }
        ]; };
        return NgxPrettyToggleComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} color
     * @param {?=} outline
     * @return {?}
     */
    function getColorClassName(color, outline) {
        if (!color) {
            return null;
        }
        return DEFAULT_PREFIX + color + (outline ? DEFAULT_OUTLINE_PREFIX : '');
    }
    /**
     * @param {?=} str
     * @return {?}
     */
    function strToBoolean(str) {
        if (typeof str === 'boolean') {
            return str;
        }
        /** @type {?} */
        var regex = /^\s*(true|1|on|enable)\s*$/i;
        return regex.test(str);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyHoverWillChangeComponent = /** @class */ (function () {
        function NgxPrettyHoverWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxPrettyHoverWillChangeComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.color || changes.outline) {
                /** @type {?} */
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                /** @type {?} */
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        NgxPrettyHoverWillChangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-hover[will-change], p-hover[will-change]',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: "state " + DEFAULT_PREFIX + "is-hover"
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyHoverWillChangeComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        NgxPrettyHoverWillChangeComponent.propDecorators = {
            color: [{ type: core.Input }],
            outline: [{ type: core.Input }]
        };
        return NgxPrettyHoverWillChangeComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyIndeterminateWillChangeComponent = /** @class */ (function () {
        function NgxPrettyIndeterminateWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxPrettyIndeterminateWillChangeComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.color || changes.outline) {
                /** @type {?} */
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                /** @type {?} */
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        NgxPrettyIndeterminateWillChangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-indeterminate[will-change], p-indeterminate[will-change]',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: "state " + DEFAULT_PREFIX + "is-indeterminate"
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyIndeterminateWillChangeComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        NgxPrettyIndeterminateWillChangeComponent.propDecorators = {
            color: [{ type: core.Input }],
            outline: [{ type: core.Input }]
        };
        return NgxPrettyIndeterminateWillChangeComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyToggleWillChangeComponent = /** @class */ (function () {
        function NgxPrettyToggleWillChangeComponent(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.outline = false;
        }
        Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOn", {
            get: /**
             * @return {?}
             */
            function () { return this.type === PrettyCheckBoxToggleType.On; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyToggleWillChangeComponent.prototype, "isToggleOff", {
            get: /**
             * @return {?}
             */
            function () { return this.type === PrettyCheckBoxToggleType.Off; },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        NgxPrettyToggleWillChangeComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            if (changes.color || changes.outline) {
                /** @type {?} */
                var oldClass = getColorClassName(changes.color ? changes.color.previousValue : this.color, changes.outline ? changes.outline.previousValue : null);
                /** @type {?} */
                var newClass = getColorClassName(changes.color ? changes.color.currentValue : this.color, changes.outline ? changes.outline.currentValue : null);
                this.renderer.removeClass(this.el.nativeElement, oldClass);
                this.renderer.addClass(this.el.nativeElement, newClass);
            }
        };
        NgxPrettyToggleWillChangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-p-toggle[will-change], p-toggle[will-change]',
                        template: "\n    <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n    <label><ng-content></ng-content></label>\n  ",
                        host: {
                            class: 'state'
                        },
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyToggleWillChangeComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        NgxPrettyToggleWillChangeComponent.propDecorators = {
            type: [{ type: core.Input }],
            isToggleOn: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "on",] }],
            isToggleOff: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "off",] }],
            color: [{ type: core.Input }],
            outline: [{ type: core.Input }]
        };
        return NgxPrettyToggleWillChangeComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable:use-host-property-decorator
    var NgxPrettyCheckboxComponent = /** @class */ (function () {
        function NgxPrettyCheckboxComponent(renderer, el, cd, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color) {
            if (_isSwitch === void 0) { _isSwitch = false; }
            if (_bigger === void 0) { _bigger = false; }
            if (_enableFocus === void 0) { _enableFocus = false; }
            if (_plain === void 0) { _plain = false; }
            if (_outline === void 0) { _outline = false; }
            this.renderer = renderer;
            this.el = el;
            this.cd = cd;
            this._stroke = _stroke;
            this._shape = _shape;
            this._animation = _animation;
            this._isSwitch = _isSwitch;
            this._bigger = _bigger;
            this._enableFocus = _enableFocus;
            this._plain = _plain;
            this._outline = _outline;
            this._color = _color;
            this._prefix = DEFAULT_PREFIX;
            this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
            this.checked = false;
            this.disabled = false;
            this.lock = false;
            this.change = new core.EventEmitter();
            this._isSwitch = strToBoolean(this._isSwitch);
            this._bigger = strToBoolean(this._bigger);
            this._enableFocus = strToBoolean(this._enableFocus);
            this._plain = strToBoolean(this._plain);
            this._outline = strToBoolean(this._outline);
        }
        /**
         * @return {?}
         */
        NgxPrettyCheckboxComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var el = this.el.nativeElement;
            if (this._isSwitch) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "switch");
            }
            if (this._bigger) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "bigger");
            }
            if (this._enableFocus) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "has-focus");
            }
            if (this._plain) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "plain");
            }
            if (this._stroke) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._stroke);
            }
            if (this._shape) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._shape);
            }
            if (this._animation) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._animation);
            }
            if (this._iconDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "icon");
            }
            if (this._svgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "svg");
            }
            if (this._imgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "image");
            }
            if (this._hoverDir || this._hoverWillChangeDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "has-hover");
            }
            if (this._indeterminateDir || this._indeterminateWillChangeDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "has-indeterminate");
            }
            if (this._isToggle) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "toggle");
            }
            if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "default");
            }
            // STATE ELEM
            if (this._color && !this._isToggle) {
                this.renderer.addClass(this._stateElem.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
            }
        };
        // ---------- PRIVATE METHODS ---------
        // ---------- PRIVATE METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        NgxPrettyCheckboxComponent.prototype._onChange = 
        // ---------- PRIVATE METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.checked = checked;
            this.change.emit({ value: value, checked: checked, event: event });
        };
        Object.defineProperty(NgxPrettyCheckboxComponent.prototype, "_isToggle", {
            get: /**
             * @return {?}
             */
            function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
            enumerable: true,
            configurable: true
        });
        // ---------- PUBLIC METHODS ---------
        // ---------- PUBLIC METHODS ---------
        /**
         * @param {?=} value
         * @return {?}
         */
        NgxPrettyCheckboxComponent.prototype.setIndeterminate = 
        // ---------- PUBLIC METHODS ---------
        /**
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            if (value === void 0) { value = true; }
            this._inputElem.nativeElement.indeterminate = value;
        };
        /**
         * @param {?} check
         * @return {?}
         */
        NgxPrettyCheckboxComponent.prototype.forceCheck = /**
         * @param {?} check
         * @return {?}
         */
        function (check) {
            this.checked = check;
            this.cd.markForCheck();
        };
        NgxPrettyCheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-pretty-checkbox:not([will-change]), p-checkbox:not([will-change])',
                        template: "\n    <input\n      #inputElem\n      type=\"checkbox\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\n\n      <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n      <label><ng-content></ng-content></label>\n\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                        // changeDetection: ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        host: {
                            'class': DEFAULT_PRETTY_CLASS_NAME
                        },
                        exportAs: 'ngxPrettyCheckbox'
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyCheckboxComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: core.ChangeDetectorRef },
            { type: PrettyCheckboxStroke, decorators: [{ type: core.Attribute, args: ['stroke',] }] },
            { type: PrettyCheckboxShape, decorators: [{ type: core.Attribute, args: ['shape',] }] },
            { type: PrettyCheckboxAnimation, decorators: [{ type: core.Attribute, args: ['animation',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['isSwitch',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['bigger',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['enableFocus',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['plain',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
            { type: PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] }
        ]; };
        NgxPrettyCheckboxComponent.propDecorators = {
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            lock: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: core.Input }],
            _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
            _stateElem: [{ type: core.ViewChild, args: ['stateElem', { static: false },] }],
            change: [{ type: core.Output }],
            _iconDir: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
            _svgDir: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
            _imgDir: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
            _hoverDir: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
            _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
            _indeterminateDir: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
            _indeterminateWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
            _toggleComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
            _toggleWillChangeComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
        };
        return NgxPrettyCheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable:use-host-property-decorator
    var NgxPrettyCheckboxWillChangeComponent = /** @class */ (function () {
        function NgxPrettyCheckboxWillChangeComponent(cd) {
            this.cd = cd;
            this._prefix = DEFAULT_PREFIX;
            this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
            this.change = new core.EventEmitter();
            this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            this.checked = false;
            this.disabled = false;
            // ----- INPUTS AND BINDING ------
            // SWITCH
            this.isSwitch = false;
            //  LOCK
            this.lock = false;
            //  BIGGER
            this.bigger = false;
            //  FOCUS
            this.enableFocus = false;
            //  PLAIN
            this.plain = false; // To remove the border ( when checkbox is checked ) 
        }
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isFill", {
            // ---------- STROKE ----------
            // Fill
            get: 
            // To remove the border ( when checkbox is checked ) 
            // ---------- STROKE ----------
            // Fill
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Fill; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSlim", {
            // Slim
            get: 
            // Slim
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Slim; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isThick", {
            // Thick
            get: 
            // Thick
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Thick; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isCurve", {
            // ---------- SHAPE ----------
            // Curve
            get: 
            // ---------- SHAPE ----------
            // Curve
            /**
             * @return {?}
             */
            function () { return this.shape === PrettyCheckboxShape.Curve; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRound", {
            // Round
            get: 
            // Round
            /**
             * @return {?}
             */
            function () { return this.shape === PrettyCheckboxShape.Round; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isSmooth", {
            // ---------- ANIMATION ----------
            // Smooth
            get: 
            // ---------- ANIMATION ----------
            // Smooth
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Smooth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isJelly", {
            // Jelly
            get: 
            // Jelly
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Jelly; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isTada", {
            // Tada
            get: 
            // Tada
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Tada; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isRotate", {
            // Rotate
            get: 
            // Rotate
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Rotate; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isPulse", {
            // Pulse
            get: 
            // Pulse
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Pulse; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isToggle", {
            get: /**
             * @return {?}
             */
            function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isDefault", {
            // DEFAULT
            get: 
            // DEFAULT
            /**
             * @return {?}
             */
            function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isHover", {
            get: /**
             * @return {?}
             */
            function () { return this._hoverComp || this._hoverWillChangeDir; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyCheckboxWillChangeComponent.prototype, "_isIndeterminate", {
            get: /**
             * @return {?}
             */
            function () { return this._indeterminateComp || this._indeterminateWillChangeComp; },
            enumerable: true,
            configurable: true
        });
        // ---------- PRIVATE METHODS ---------
        // ---------- PRIVATE METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        NgxPrettyCheckboxWillChangeComponent.prototype._onChange = 
        // ---------- PRIVATE METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.checked = checked;
            this.change.emit({ value: value, checked: checked, event: event });
        };
        // ---------- PUBLIC METHODS ---------
        // ---------- PUBLIC METHODS ---------
        /**
         * @param {?=} value
         * @return {?}
         */
        NgxPrettyCheckboxWillChangeComponent.prototype.setIndeterminate = 
        // ---------- PUBLIC METHODS ---------
        /**
         * @param {?=} value
         * @return {?}
         */
        function (value) {
            if (value === void 0) { value = true; }
            this._inputElem.nativeElement.indeterminate = value;
        };
        /**
         * @param {?} check
         * @return {?}
         */
        NgxPrettyCheckboxWillChangeComponent.prototype.forceCheck = /**
         * @param {?} check
         * @return {?}
         */
        function (check) {
            this.checked = check;
            this.cd.markForCheck();
        };
        NgxPrettyCheckboxWillChangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-pretty-checkbox[will-change], p-checkbox[will-change]',
                        template: "\n    <input\n      #inputElem\n      type=\"checkbox\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div *ngIf=\"!_isToggle\" class=\"state\"\n        [ngClass]=\"[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]\">\n\n        <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n        <label><ng-content></ng-content></label>\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        host: {
                            'class': DEFAULT_PRETTY_CLASS_NAME
                        },
                        exportAs: 'ngxPrettyCheckboxWillChange'
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyCheckboxWillChangeComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef }
        ]; };
        NgxPrettyCheckboxWillChangeComponent.propDecorators = {
            _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
            change: [{ type: core.Output }],
            stroke: [{ type: core.Input }],
            shape: [{ type: core.Input }],
            animation: [{ type: core.Input }],
            color: [{ type: core.Input }],
            outline: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            isSwitch: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "switch",] }, { type: core.Input }],
            lock: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: core.Input }],
            bigger: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "bigger",] }, { type: core.Input }],
            enableFocus: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "has-focus",] }, { type: core.Input }],
            plain: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "plain",] }, { type: core.Input }],
            _isFill: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Fill,] }],
            _isSlim: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Slim,] }],
            _isThick: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Thick,] }],
            _isCurve: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Curve,] }],
            _isRound: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Round,] }],
            _isSmooth: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Smooth,] }],
            _isJelly: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Jelly,] }],
            _isTada: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Tada,] }],
            _isRotate: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Rotate,] }],
            _isPulse: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Pulse,] }],
            _toggleComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
            _toggleWillChangeComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
            _isToggle: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "toggle",] }],
            _isDefault: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "default",] }],
            _iconElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "icon",] }, { type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
            _svgElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "svg",] }, { type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
            _imageElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "image",] }, { type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
            _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
            _hoverComp: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
            _isHover: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "has-hover",] }],
            _indeterminateComp: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateComponent, { static: false },] }],
            _indeterminateWillChangeComp: [{ type: core.ContentChild, args: [NgxPrettyIndeterminateWillChangeComponent, { static: false },] }],
            _isIndeterminate: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "has-indeterminate",] }]
        };
        return NgxPrettyCheckboxWillChangeComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxPrettyRadioService = /** @class */ (function () {
        function NgxPrettyRadioService() {
        }
        NgxPrettyRadioService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        NgxPrettyRadioService.ctorParameters = function () { return []; };
        /** @nocollapse */ NgxPrettyRadioService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function NgxPrettyRadioService_Factory() { return new NgxPrettyRadioService(); }, token: NgxPrettyRadioService, providedIn: "root" });
        return NgxPrettyRadioService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nextId = 1;
    var NgxPrettyRadioGroupDirective = /** @class */ (function () {
        function NgxPrettyRadioGroupDirective() {
            this.name = GROUP_NAME + nextId++;
            this.change = new core.EventEmitter();
        }
        /**
         * @param {?} event
         * @return {?}
         */
        NgxPrettyRadioGroupDirective.prototype._emitChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.change.emit(event);
        };
        NgxPrettyRadioGroupDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ngx-pretty-radio-group, p-radio-group',
                        providers: [NgxPrettyRadioService],
                        exportAs: 'ngxRadioGroup'
                    },] }
        ];
        /** @nocollapse */
        NgxPrettyRadioGroupDirective.ctorParameters = function () { return []; };
        NgxPrettyRadioGroupDirective.propDecorators = {
            change: [{ type: core.Output }]
        };
        return NgxPrettyRadioGroupDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable:use-host-property-decorator
    var NgxPrettyRadioComponent = /** @class */ (function () {
        function NgxPrettyRadioComponent(renderer, el, radioGroup, _stroke, _shape, _animation, _isSwitch, _bigger, _enableFocus, _plain, _outline, _color, _name) {
            if (_isSwitch === void 0) { _isSwitch = false; }
            if (_bigger === void 0) { _bigger = false; }
            if (_enableFocus === void 0) { _enableFocus = false; }
            if (_plain === void 0) { _plain = false; }
            if (_outline === void 0) { _outline = false; }
            this.renderer = renderer;
            this.el = el;
            this.radioGroup = radioGroup;
            this._stroke = _stroke;
            this._shape = _shape;
            this._animation = _animation;
            this._isSwitch = _isSwitch;
            this._bigger = _bigger;
            this._enableFocus = _enableFocus;
            this._plain = _plain;
            this._outline = _outline;
            this._color = _color;
            this._name = _name;
            this._prefix = DEFAULT_PREFIX;
            this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
            this.checked = false;
            this.disabled = false;
            this.lock = false;
            this.change = new core.EventEmitter();
            if (!this._name && this.radioGroup) {
                this._name = this.radioGroup.name;
            }
            this._isSwitch = strToBoolean(this._isSwitch);
            this._bigger = strToBoolean(this._bigger);
            this._enableFocus = strToBoolean(this._enableFocus);
            this._plain = strToBoolean(this._plain);
            this._outline = strToBoolean(this._outline);
        }
        /**
         * @return {?}
         */
        NgxPrettyRadioComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var el = this.el.nativeElement;
            if (this._isSwitch) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "switch");
            }
            if (this._bigger) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "bigger");
            }
            if (this._enableFocus) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "has-focus");
            }
            if (this._plain) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "plain");
            }
            if (this._stroke) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._stroke);
            }
            if (this._shape) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._shape);
            }
            if (this._animation) {
                this.renderer.addClass(el, "" + DEFAULT_PREFIX + this._animation);
            }
            if (this._iconDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "icon");
            }
            if (this._svgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "svg");
            }
            if (this._imgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "image");
            }
            if (this._hoverDir || this._hoverWillChangeDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "has-hover");
            }
            if (this._isToggle) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "toggle");
            }
            if (!this._isSwitch && !this._iconDir && !this._svgDir && !this._imgDir) {
                this.renderer.addClass(el, DEFAULT_PREFIX + "default");
            }
            // STATE ELEM
            if (this._color && !this._isToggle) {
                this.renderer.addClass(this._stateElem.nativeElement, "" + DEFAULT_PREFIX + this._color + (this._outline ? DEFAULT_OUTLINE_PREFIX : ''));
            }
        };
        // ---------- METHODS ---------
        // ---------- METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        NgxPrettyRadioComponent.prototype._onChange = 
        // ---------- METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.change.emit({ value: value, checked: checked, event: event });
            if (this.radioGroup) {
                this.radioGroup._emitChange({ value: value, checked: checked, event: event });
            }
        };
        Object.defineProperty(NgxPrettyRadioComponent.prototype, "_isToggle", {
            get: /**
             * @return {?}
             */
            function () { return this._toggleComps.length === 2 || this._toggleWillChangeComps.length === 2; },
            enumerable: true,
            configurable: true
        });
        NgxPrettyRadioComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-pretty-radio:not([will-change]), p-radio:not([will-change])',
                        template: "\n    <input\n      #inputElem\n      type=\"radio\"\n      [name]=\"_name\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div #stateElem *ngIf=\"!_isToggle\" class=\"state\">\n\n      <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n      <label><ng-content></ng-content></label>\n\n    </div>\n\n    <ng-content select=\"ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                        // changeDetection: ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        host: {
                            'class': DEFAULT_PRETTY_CLASS_NAME
                        },
                        exportAs: 'ngxPrettyRadio'
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyRadioComponent.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: NgxPrettyRadioGroupDirective, decorators: [{ type: core.Optional }] },
            { type: PrettyCheckboxStroke, decorators: [{ type: core.Attribute, args: ['stroke',] }] },
            { type: PrettyCheckboxShape, decorators: [{ type: core.Attribute, args: ['shape',] }] },
            { type: PrettyCheckboxAnimation, decorators: [{ type: core.Attribute, args: ['animation',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['isSwitch',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['bigger',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['enableFocus',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['plain',] }] },
            { type: undefined, decorators: [{ type: core.Attribute, args: ['outline',] }] },
            { type: PrettyCheckboxColor, decorators: [{ type: core.Attribute, args: ['color',] }] },
            { type: String, decorators: [{ type: core.Attribute, args: ['name',] }] }
        ]; };
        NgxPrettyRadioComponent.propDecorators = {
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            lock: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: core.Input }],
            _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
            _stateElem: [{ type: core.ViewChild, args: ['stateElem', { static: false },] }],
            change: [{ type: core.Output }],
            _iconDir: [{ type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
            _svgDir: [{ type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
            _imgDir: [{ type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
            _hoverDir: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
            _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
            _toggleComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
            _toggleWillChangeComps: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }]
        };
        return NgxPrettyRadioComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable:use-host-property-decorator
    var NgxPrettyRadioWillChangeComponent = /** @class */ (function () {
        function NgxPrettyRadioWillChangeComponent(radioGroup) {
            this.radioGroup = radioGroup;
            this._prefix = DEFAULT_PREFIX;
            this._outlinePrefix = DEFAULT_OUTLINE_PREFIX;
            this.change = new core.EventEmitter();
            this.outline = false; // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            // COLOR . Can be used as Solid ( p-primary ) or Outline ( p-primary-o ).
            this.checked = false;
            this.disabled = false;
            // ----- INPUTS AND BINDING ------
            // SWITCH
            this.isSwitch = false;
            //  LOCK
            this.lock = false;
            //  BIGGER
            this.bigger = false;
            //  FOCUS
            this.enableFocus = false;
            //  PLAIN
            this.plain = false; // To remove the border ( when checkbox is checked )
            if (radioGroup) {
                this.radioGroupName = radioGroup.name;
            }
        }
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isFill", {
            // ---------- STROKE ----------
            // Fill
            get: 
            // To remove the border ( when checkbox is checked )
            // ---------- STROKE ----------
            // Fill
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Fill; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSlim", {
            // Slim
            get: 
            // Slim
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Slim; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isThick", {
            // Thick
            get: 
            // Thick
            /**
             * @return {?}
             */
            function () { return this.stroke === PrettyCheckboxStroke.Thick; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isCurve", {
            // ---------- SHAPE ----------
            // Curve
            get: 
            // ---------- SHAPE ----------
            // Curve
            /**
             * @return {?}
             */
            function () { return this.shape === PrettyCheckboxShape.Curve; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRound", {
            // Round
            get: 
            // Round
            /**
             * @return {?}
             */
            function () { return this.shape === PrettyCheckboxShape.Round; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isSmooth", {
            // ---------- ANIMATION ----------
            // Smooth
            get: 
            // ---------- ANIMATION ----------
            // Smooth
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Smooth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isJelly", {
            // Jelly
            get: 
            // Jelly
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Jelly; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isTada", {
            // Tada
            get: 
            // Tada
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Tada; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isRotate", {
            // Rotate
            get: 
            // Rotate
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Rotate; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isPulse", {
            // Pulse
            get: 
            // Pulse
            /**
             * @return {?}
             */
            function () { return this.animation === PrettyCheckboxAnimation.Pulse; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isToggle", {
            get: /**
             * @return {?}
             */
            function () { return this._toggleComp.length === 2 || this._toggleWillChangeComp.length === 2; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isDefault", {
            // DEFAULT
            get: 
            // DEFAULT
            /**
             * @return {?}
             */
            function () { return !this.isSwitch && !this._iconElem && !this._svgElem && !this._imageElem; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxPrettyRadioWillChangeComponent.prototype, "_isHover", {
            get: /**
             * @return {?}
             */
            function () { return this._hoverComp || this._hoverWillChangeDir; },
            enumerable: true,
            configurable: true
        });
        // ---------- METHODS ---------
        // ---------- METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        NgxPrettyRadioWillChangeComponent.prototype._onChange = 
        // ---------- METHODS ---------
        /**
         * @param {?} event
         * @param {?} checked
         * @param {?} value
         * @return {?}
         */
        function (event, checked, value) {
            // I stop propagation on the change event.
            // Otherwise the change event, from the input element, will bubble up and
            event.stopPropagation();
            this.change.emit({ value: value, checked: checked, event: event });
            if (this.radioGroup) {
                this.radioGroup._emitChange({ value: value, checked: checked, event: event });
            }
        };
        NgxPrettyRadioWillChangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-pretty-radio[will-change], p-radio[will-change]',
                        template: "\n    <input\n      #inputElem\n      type=\"radio\"\n      [name]=\"name || radioGroupName\"\n      [value]=\"value\"\n      [checked]=\"checked\"\n      [disabled]=\"disabled\"\n      (change)=\"_onChange($event, inputElem.checked, inputElem.value)\"/>\n\n    <div *ngIf=\"!_isToggle\" class=\"state\"\n        [ngClass]=\"[ color ? _prefix + color + (outline ? _outlinePrefix : '') : '' ]\">\n\n        <ng-content select=\"[pIcon], [p-icon], [pSvg], [p-svg], [pImage], [p-image]\"></ng-content>\n        <label><ng-content></ng-content></label>\n    </div>\n\n    <ng-content select=\"ngx-p-indeterminate, p-indeterminate, ngx-p-hover, p-hover, ngx-p-toggle, p-toggle\"></ng-content>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        host: {
                            'class': DEFAULT_PRETTY_CLASS_NAME
                        },
                        exportAs: 'ngxPrettyRadio'
                    }] }
        ];
        /** @nocollapse */
        NgxPrettyRadioWillChangeComponent.ctorParameters = function () { return [
            { type: NgxPrettyRadioGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        NgxPrettyRadioWillChangeComponent.propDecorators = {
            _inputElem: [{ type: core.ViewChild, args: ['inputElem', { static: true },] }],
            change: [{ type: core.Output }],
            stroke: [{ type: core.Input }],
            shape: [{ type: core.Input }],
            animation: [{ type: core.Input }],
            color: [{ type: core.Input }],
            outline: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            value: [{ type: core.Input }],
            name: [{ type: core.Input }],
            isSwitch: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "switch",] }, { type: core.Input }],
            lock: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "locked",] }, { type: core.Input }],
            bigger: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "bigger",] }, { type: core.Input }],
            enableFocus: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "has-focus",] }, { type: core.Input }],
            plain: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "plain",] }, { type: core.Input }],
            _isFill: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Fill,] }],
            _isSlim: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Slim,] }],
            _isThick: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxStroke.Thick,] }],
            _isCurve: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Curve,] }],
            _isRound: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxShape.Round,] }],
            _isSmooth: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Smooth,] }],
            _isJelly: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Jelly,] }],
            _isTada: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Tada,] }],
            _isRotate: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Rotate,] }],
            _isPulse: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + PrettyCheckboxAnimation.Pulse,] }],
            _toggleComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleComponent,] }],
            _toggleWillChangeComp: [{ type: core.ContentChildren, args: [NgxPrettyToggleWillChangeComponent,] }],
            _isToggle: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "toggle",] }],
            _isDefault: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "default",] }],
            _iconElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "icon",] }, { type: core.ContentChild, args: [NgxPrettyIconDirective, { static: false },] }],
            _svgElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "svg",] }, { type: core.ContentChild, args: [NgxPrettySvgDirective, { static: false },] }],
            _imageElem: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "image",] }, { type: core.ContentChild, args: [NgxPrettyImageDirective, { static: false },] }],
            _hoverWillChangeDir: [{ type: core.ContentChild, args: [NgxPrettyHoverWillChangeComponent, { static: false },] }],
            _hoverComp: [{ type: core.ContentChild, args: [NgxPrettyHoverComponent, { static: false },] }],
            _isHover: [{ type: core.HostBinding, args: ["class." + DEFAULT_PREFIX + "has-hover",] }]
        };
        return NgxPrettyRadioWillChangeComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DECLARATIONS = [
        NgxPrettyCheckboxComponent,
        NgxPrettyCheckboxWillChangeComponent,
        NgxPrettyIconDirective,
        NgxPrettySvgDirective,
        NgxPrettyImageDirective,
        NgxPrettyToggleComponent,
        NgxPrettyToggleWillChangeComponent,
        NgxPrettyHoverComponent,
        NgxPrettyHoverWillChangeComponent,
        NgxPrettyIndeterminateComponent,
        NgxPrettyIndeterminateWillChangeComponent,
        NgxPrettyRadioGroupDirective,
        NgxPrettyRadioComponent,
        NgxPrettyRadioWillChangeComponent
    ];
    var NgxPrettyCheckboxModule = /** @class */ (function () {
        function NgxPrettyCheckboxModule() {
        }
        NgxPrettyCheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        declarations: [DECLARATIONS],
                        exports: [DECLARATIONS]
                    },] }
        ];
        return NgxPrettyCheckboxModule;
    }());

    exports.NgxPrettyCheckboxComponent = NgxPrettyCheckboxComponent;
    exports.NgxPrettyCheckboxModule = NgxPrettyCheckboxModule;
    exports.NgxPrettyCheckboxWillChangeComponent = NgxPrettyCheckboxWillChangeComponent;
    exports.NgxPrettyHoverComponent = NgxPrettyHoverComponent;
    exports.NgxPrettyHoverWillChangeComponent = NgxPrettyHoverWillChangeComponent;
    exports.NgxPrettyIconDirective = NgxPrettyIconDirective;
    exports.NgxPrettyImageDirective = NgxPrettyImageDirective;
    exports.NgxPrettyIndeterminateComponent = NgxPrettyIndeterminateComponent;
    exports.NgxPrettyIndeterminateWillChangeComponent = NgxPrettyIndeterminateWillChangeComponent;
    exports.NgxPrettyRadioComponent = NgxPrettyRadioComponent;
    exports.NgxPrettyRadioGroupDirective = NgxPrettyRadioGroupDirective;
    exports.NgxPrettyRadioWillChangeComponent = NgxPrettyRadioWillChangeComponent;
    exports.NgxPrettySvgDirective = NgxPrettySvgDirective;
    exports.NgxPrettyToggleComponent = NgxPrettyToggleComponent;
    exports.NgxPrettyToggleWillChangeComponent = NgxPrettyToggleWillChangeComponent;
    exports.PrettyCheckBoxToggleType = PrettyCheckBoxToggleType;
    exports.PrettyCheckboxAnimation = PrettyCheckboxAnimation;
    exports.PrettyCheckboxColor = PrettyCheckboxColor;
    exports.PrettyCheckboxShape = PrettyCheckboxShape;
    exports.PrettyCheckboxStroke = PrettyCheckboxStroke;
    exports.ɵa = DEFAULT_PRETTY_CLASS_NAME;
    exports.ɵb = DEFAULT_PREFIX;
    exports.ɵc = NgxPrettyRadioService;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngx-pretty-checkbox.umd.js.map
